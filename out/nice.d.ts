import { app } from './lib/nice-app';
import { Component as ComponentInternal, ComponentPropertyDefinitions } from './lib/nice-component';
import { RenderFunctionReturn, RenderTemplate } from './lib/nice-renderer';
import { State as StateInternal } from './lib/nice-state';
import { mapper, styler } from './lib/nice-utils';
type State<T> = Pick<StateInternal<T>, 'get' | 'set'>;
type Prop<T> = T | State<T>;
type Component<T> = Omit<ComponentInternal<T>, keyof ComponentInternal<T>>;
type Node = Component<any> | State<any> | unknown;
type Ref<T> = Pick<State<T extends Event ? T : T>, 'get'>;
declare const state: <T = unknown>(value: T) => State<T>;
declare const computed: <U = unknown, T = undefined>(fn: (e: U) => T, deps?: (State<any> | unknown)[]) => State<T extends undefined ? U : T>;
declare const render: (template: RenderTemplate, ...args: Node[]) => (id: string) => {
    html: string;
    hydrate: () => HTMLDivElement;
};
declare const component: <T extends ComponentPropertyDefinitions | undefined = undefined>(fn: (props: T, key?: string) => RenderFunctionReturn | void) => T extends undefined ? () => Component<T> : (props: T, key?: string) => T extends undefined ? () => Component<T> : (props: T, key?: string) => Component<T>;
declare const ref: <T extends HTMLElement>(fn?: ((element: T) => void) | undefined) => Ref<T>;
declare const store: <T = object>(values: T) => <U extends keyof T>(key: U) => State<T[U]>;
declare const valueOf: <T extends unknown>(property: T) => T extends Prop<infer U> ? U : never;
declare const hasWindow: boolean;
type ComponentType<T extends Component<any>> = T extends infer U extends (...args: any) => any ? Parameters<U>[0] : string;
export { ref, app, store, state, styler, mapper, render, valueOf, computed, component, hasWindow, };
export type { Node, Prop, State, ComponentType, };
